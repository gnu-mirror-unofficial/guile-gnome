#!/bin/sh
exec ${srcdir:-.}/guile-test-env guile -s "$0" "$@"
!#

(define-module (test-suite test-gobject)
  #:use-module (oop goops)
  #:use-module (gnome gobject)
  #:use-module (gnome gobject primitives)
  #:use-module (test-suite lib)
  #:use-module (test-suite exceptions))

(pass-if "basic types defined"
	 (and (defined? 'gtype:gchar)
	      (defined? 'gtype:guchar)
	      (defined? 'gtype:gboolean)
	      (defined? 'gtype:gint)
	      (defined? 'gtype:guint)
	      (defined? 'gtype:glong)
	      (defined? 'gtype:gulong)
	      (defined? 'gtype:gfloat)
	      (defined? 'gtype:gdouble)
	      (defined? 'gtype:gchararray)))

(pass-if "extended types defined"
	 (and (defined? 'gtype:genum)
	      (defined? 'gtype:gflags)
	      (defined? 'gtype:gboxed)
	      (defined? 'gtype:gclosure)
	      (defined? 'gtype:gobject)
              (defined? 'gtype:gvalue-array)))

(with-test-prefix "basic values"
  (define (test class value)
    (equal? (gvalue->scm (make class #:value value)) value))
  
  (pass-if-exception "#:value arg missing"
                     exception:value-arg-missing
                     (make <guchar>))

  (pass-if "creating gchar"
           (test <gchar> #\space))

  (pass-if "creating guchar"
           (test <guchar> #\space))

  (pass-if "creating gboolean #f"
           (test <gboolean> #f))

  (pass-if "creating gboolean #t"
           (test <gboolean> #t))

  (pass-if "creating gint"
           (test <gint> 511))

  (pass-if "creating guint"
           (test <guint> 511))

  (pass-if-exception "creating guint"
                     exception:out-of-range
                     (make <guint> #:value -1))

  (pass-if "creating glong"
           (test <glong> 511))

  (pass-if "creating gulong"
           (test <gulong> 511))

  (pass-if-exception "creating gulong"
                     exception:out-of-range
                     (make <gulong> #:value -1))

  (pass-if "creating gfloat"
           (test <gfloat> 4.5))

  (pass-if "creating gdouble"
           (test <gdouble> 4.1234))

  (pass-if "creating gchararray"
           (test <gchararray> "This is a test"))

  (pass-if "creating empty gchararray"
           (test <gchararray> #f))

  )

(with-test-prefix "creating genum and gflags types"
  
  (pass-if "creating genum type"
           (let* ((class (make-class (list <genum>) '()
                           #:name '<enum-test>
                           #:vtable #((a "Foo" 1) (b "Hello" 2))))
                  (type (gtype-class->type class)))
             (and (eq? (gtype->fundamental type)
                       gtype:genum)
                  (eq? type (gtype-from-name "EnumTest")))))

  (pass-if "creating gflags type"
           (let* ((class (make-class (list <gflags>) '()
                           #:name '<flags-test>
                           #:vtable #((c "AAAA" 4) (d "BBBB" 8))))
                  (type (gtype-class->type class)))
             (and (eq? (gtype->fundamental type)
                       gtype:gflags)
                  (eq? type (gtype-from-name "FlagsTest")))))
  )

(with-test-prefix "genum values"
  
  (define enum-class (gtype->class (gtype-from-name "EnumTest")))
  
  (pass-if "getting enum type from class"
           (is-a? (gtype-class->type enum-class) <gtype>))
  
  (pass-if "getting enum type class"
           (is-a? enum-class <gtype-class>))
  
  (pass-if "creating enum by nick"
           (gvalue? (make enum-class #:value 'a)))
  
  (pass-if "creating enum by name"
           (gvalue? (make enum-class #:value "Foo")))
  
  (pass-if "creating enum by value"
           (gvalue? (make enum-class #:value 1)))
  
  (pass-if "getting enum nick"
           (eq? (genum->symbol (make enum-class #:value 'a)) 'a))
  
  (pass-if "getting enum name"
           (equal? (genum->name (make enum-class #:value 'a)) "Foo"))

  (pass-if "getting enum value"
           (equal? (genum->value (make enum-class #:value 'a)) 1))
  
  )

(with-test-prefix "gflags values"

  (define flags-class (gtype->class (gtype-from-name "FlagsTest")))
  
  (pass-if "getting flags type from class"
           (is-a? (gtype-class->type flags-class) <gtype>))

  (pass-if "getting flags type class"
           (is-a? flags-class <gtype-class>))

  (pass-if "creating flags by nick"
           (gvalue? (make flags-class #:value '(c d))))

  (pass-if "creating flags by name"
           (gvalue? (make flags-class #:value '("AAAA" "BBBB"))))

  (pass-if "creating flags by value"
           (gvalue? (make flags-class #:value '(4 8))))

  (pass-if "creating flags by or'd value"
           (gvalue? (make flags-class #:value 12)))

  (pass-if "creating flags by mixed list"
           (gvalue? (make flags-class #:value '(c "BBBB"))))

  (pass-if "getting flags nicks"
           (equal? (gflags->symbol-list
                    (make flags-class #:value '(4 8))) '(c d)))

  (pass-if "getting flags names"
           (equal? (gflags->name-list (make flags-class #:value '(4 8)))
                   '("AAAA" "BBBB")))

  (pass-if "getting flags values"
           (equal? (gflags->value-list (make flags-class #:value '(4 8)))
                   '(4 8)))
  )

(with-test-prefix "creating gclosure"
  
  (define func-without-args (lambda () "Hello World"))
  (define my-closure? (lambda (x) (is-a? x <gclosure>)))
  (define long-arg (list->vector (list (make <glong> #:value 82))))
  
  (pass-if "creating gclosure"
           (my-closure? (make <gclosure> #:func func-without-args)))
  
  (pass-if "creating gclosure with return type"
           (my-closure? (make <gclosure> #:func func-without-args
                              #:return-type gtype:gchararray)))
  
  (pass-if "creating gclosure with arg"
           (my-closure? (make <gclosure> #:func func-without-args
                              #:return-type gtype:gchararray
                              #:param-types (list gtype:glong))))
  )

(with-test-prefix "invoking gclosure"
  (define long-arg (list->vector (list (make <glong> #:value 82))))
  
  (define closure-without-args
    (make <gclosure> #:func (lambda () "Hello World")))
  
  (define closure-with-retval
    (make <gclosure> #:func (lambda () "Hello World")
          #:return-type gtype:gchararray))
  
  (define closure-with-boxed-retval
    (make <gclosure> #:func (lambda () (gclosure-primitive-new (lambda () #t)))
          #:return-type gtype:gclosure))
  
  (pass-if "invoking gclosure"
           (unspecified? (gclosure-invoke closure-without-args)))
  
  (pass-if-exception "invoking gclosure"
                     exception:wrong-number-of-args
                     (gclosure-invoke closure-without-args long-arg))
  
  (pass-if "invoking gclosure with retval"
           (string? (gclosure-invoke closure-with-retval)))
  
  (pass-if "invoking gclosure checking retval"
           (equal? (gclosure-invoke closure-with-retval)
                   "Hello World"))
  
  (pass-if "invoking gclosure with boxed retval"
           (gvalue? (gclosure-invoke closure-with-boxed-retval)))
  )

;; Local Variables:
;; mode: scheme
;; End:
